<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Programming Node Designer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <div class="row justify-content-center">
            <div class="col-md-10">
                <h2 class="text-center mb-4">ðŸŽ¯ Visual Programming Node Designer</h2>
                <p class="text-center text-muted mb-4">Define your custom node with BDD-style tests. AI will generate the EventEmitter and manifest.json</p>

                <!-- Profile Selection -->
                <div class="row mb-4">
                    <div class="col-md-6 mx-auto">
                        <div class="card">
                            <div class="card-body text-center">
                                <h5 class="card-title">ðŸŽ¨ Start with a Profile</h5>
                                <p class="card-text text-muted">Choose from inspired examples or start from scratch</p>
                                <select id="profileSelector" class="form-select mb-3" onchange="loadProfile()">
                                    <option value="">ðŸŽ¯ Start from scratch</option>
                                    <optgroup label="ðŸ”— Supervision Patterns">
                                        <option value="job_supervisor">Job Supervisor - Manages worker processes</option>
                                        <option value="http_worker">HTTP Worker - Fetches data from APIs</option>
                                    </optgroup>
                                    <optgroup label="ðŸ“¦ Queue Patterns">
                                        <option value="push_queue">Push Queue - Stores and distributes data</option>
                                        <option value="pull_queue">Pull Queue - On-demand data retrieval</option>
                                        <option value="output_queue">Output Queue - Data accumulation</option>
                                    </optgroup>
                                    <optgroup label="ðŸŒ HTTP Operations">
                                        <option value="http_fetch">HTTP Fetch - Generic web requests</option>
                                        <option value="api_client">API Client - Structured API calls</option>
                                    </optgroup>
                                    <optgroup label="âš™ï¸ Data Processing">
                                        <option value="json_parser">JSON Parser - Parse JSON strings</option>
                                        <option value="text_transformer">Text Transformer - String manipulation</option>
                                        <option value="data_filter">Data Filter - Conditional processing</option>
                                    </optgroup>
                                    <optgroup label="ðŸŽ¯ Reducers/Consumers">
                                        <option value="data_collector">Data Collector - Aggregates results</option>
                                        <option value="logger">Logger - Outputs to console/file</option>
                                        <option value="validator">Validator - Data validation sink</option>
                                    </optgroup>
                                </select>
                                <small class="text-muted">ðŸ’¡ Profiles provide powerful design patterns you can customize</small>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="wizardForm"></div>

                <div class="mt-4 text-center">
                    <button type="button" class="btn btn-primary btn-lg me-3" onclick="generatePrompt()">
                        ðŸ¤– Generate AI Prompt
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="resetForm()">
                        ðŸ”„ Reset Form
                    </button>
                </div>

                <div class="mt-5" id="promptOutput" style="display: none;">
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0">ðŸŽ¯ AI Prompt for Node Generation</h5>
                        </div>
                        <div class="card-body">
                            <pre id="generatedPrompt" class="bg-dark text-light p-3 rounded" style="white-space: pre-wrap;"></pre>
                            <button type="button" class="btn btn-outline-primary mt-2" onclick="copyPrompt()">
                                ðŸ“‹ Copy to Clipboard
                            </button>
                        </div>
                    </div>
                </div>

                <div class="mt-4">
                    <details>
                        <summary class="btn btn-outline-info">ðŸ“Š View Form Data</summary>
                        <pre id="formData" class="bg-dark text-light p-3 rounded mt-2"></pre>
                    </details>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <script>
        // Form configuration for Visual Programming Node Designer
        const form = [
            [
                // Basic Node Information
                {
                    "name": "nodeTitle",
                    "type": "text",
                    "label": "Node Title",
                    "description": "A clear, explicit title for your visual programming node (e.g., 'Text Transformer', 'Data Filter', 'HTTP Request')",
                    "value": "",
                    "required": true,
                    "placeholder": "My Custom Node"
                },
                {
                    "name": "nodeType",
                    "type": "select",
                    "label": "Node Type",
                    "description": "Select the type of node based on its data flow role",
                    "value": "",
                    "required": true,
                    "options": [
                        {"value": "", "text": "Choose node type..."},
                        {"value": "PRODUCER", "text": "PRODUCER - Generates data (sources)"},
                        {"value": "TRANSDUCER", "text": "TRANSDUCER - Transforms data (processors)"},
                        {"value": "REDUCER", "text": "REDUCER - Consumes data (sinks)"}
                    ]
                }
            ],
            [
                // BDD Narrative Section
                {
                    "name": "userRole",
                    "type": "text",
                    "label": "As a...",
                    "description": "The person or role who will benefit from this node feature",
                    "value": "",
                    "required": true,
                    "placeholder": "developer, data analyst, content creator"
                },
                {
                    "name": "userWant",
                    "type": "textarea",
                    "label": "I want...",
                    "description": "The feature or capability this node should provide",
                    "value": "",
                    "required": true,
                    "rows": "2",
                    "placeholder": "to transform text data, to filter arrays, to fetch web content"
                },
                {
                    "name": "userBenefit",
                    "type": "textarea",
                    "label": "So that...",
                    "description": "The benefit or value this node will provide",
                    "value": "",
                    "required": true,
                    "rows": "2",
                    "placeholder": "I can automate data processing, I can build better workflows"
                }
            ],
            [
                // Test Scenario 1
                {
                    "name": "scenario1Title",
                    "type": "text",
                    "label": "Test Scenario 1 - Title",
                    "description": "A descriptive title for your first test scenario",
                    "value": "",
                    "required": true,
                    "placeholder": "Happy path with valid input"
                },
                {
                    "name": "scenario1Given",
                    "type": "textarea",
                    "label": "Given...",
                    "description": "The initial context and setup for this scenario",
                    "value": "",
                    "required": true,
                    "rows": "2",
                    "placeholder": "the node receives a packet with text data 'hello world'"
                },
                {
                    "name": "scenario1When",
                    "type": "textarea",
                    "label": "When...",
                    "description": "The event or action that triggers the scenario",
                    "value": "",
                    "required": true,
                    "rows": "2",
                    "placeholder": "the packet is processed through the transform function"
                },
                {
                    "name": "scenario1Then",
                    "type": "textarea",
                    "label": "Then...",
                    "description": "The expected outcome or result",
                    "value": "",
                    "required": true,
                    "rows": "2",
                    "placeholder": "it should emit a packet with data 'HELLO WORLD'"
                }
            ],
            [
                // Test Scenario 2
                {
                    "name": "scenario2Title",
                    "type": "text",
                    "label": "Test Scenario 2 - Title",
                    "description": "A descriptive title for your second test scenario",
                    "value": "",
                    "placeholder": "Edge case with empty input"
                },
                {
                    "name": "scenario2Given",
                    "type": "textarea",
                    "label": "Given...",
                    "description": "The initial context for this edge case or alternative scenario",
                    "value": "",
                    "rows": "2",
                    "placeholder": "the node receives a packet with empty or null data"
                },
                {
                    "name": "scenario2When",
                    "type": "textarea",
                    "label": "When...",
                    "description": "The triggering event for this scenario",
                    "value": "",
                    "rows": "2",
                    "placeholder": "the processing function is called"
                },
                {
                    "name": "scenario2Then",
                    "type": "textarea",
                    "label": "Then...",
                    "description": "What should happen in this case",
                    "value": "",
                    "rows": "2",
                    "placeholder": "it should handle gracefully and emit appropriate result"
                }
            ],
            [
                // Test Scenario 3
                {
                    "name": "scenario3Title",
                    "type": "text",
                    "label": "Test Scenario 3 - Title (Optional)",
                    "description": "A descriptive title for your third test scenario",
                    "value": "",
                    "placeholder": "Error handling scenario"
                },
                {
                    "name": "scenario3Given",
                    "type": "textarea",
                    "label": "Given...",
                    "description": "The initial context for this scenario",
                    "value": "",
                    "rows": "2",
                    "placeholder": "the node receives invalid or malformed data"
                },
                {
                    "name": "scenario3When",
                    "type": "textarea",
                    "label": "When...",
                    "description": "The triggering event",
                    "value": "",
                    "rows": "2",
                    "placeholder": "the processing function attempts to handle the data"
                },
                {
                    "name": "scenario3Then",
                    "type": "textarea",
                    "label": "Then...",
                    "description": "Expected error handling behavior",
                    "value": "",
                    "rows": "2",
                    "placeholder": "it should emit an error packet or handle gracefully"
                }
            ],
            [
                // Additional Configuration
                {
                    "name": "customProperties",
                    "type": "textarea",
                    "label": "Custom Properties (Optional)",
                    "description": "Any custom properties this node should have (e.g., colorName, predicateFunction). One per line with brief description.",
                    "value": "",
                    "rows": "3",
                    "placeholder": "colorName - string: the color to apply\nthreshold - number: minimum value for filtering\nregexPattern - string: pattern for text matching"
                },
                {
                    "name": "additionalContext",
                    "type": "textarea",
                    "label": "Additional Context (Optional)",
                    "description": "Any additional information, constraints, or requirements for the AI to consider",
                    "value": "",
                    "rows": "3",
                    "placeholder": "Should handle Unicode text, must be memory efficient, requires async operation support"
                }
            ]
        ];

        // Profiles data structure
        const profiles = {
            job_supervisor: {
                nodeTitle: "Job Supervisor",
                nodeType: "TRANSDUCER",
                userRole: "system architect",
                userWant: "to manage and coordinate worker processes that handle tasks",
                userBenefit: "I can build reliable, fault-tolerant processing systems with proper error handling",
                scenario1Title: "Successfully coordinate worker task",
                scenario1Given: "a supervisor node is connected to a worker node and receives a task packet",
                scenario1When: "the task is sent to the worker and the worker responds with completion",
                scenario1Then: "it should emit the worker's result and mark the task as complete",
                scenario2Title: "Handle worker error gracefully",
                scenario2Given: "a supervisor node sends a task to a worker",
                scenario2When: "the worker responds with an error event",
                scenario2Then: "it should emit an error packet and attempt recovery or escalation",
                scenario3Title: "Manage worker timeout",
                scenario3Given: "a supervisor node sends a task to a worker",
                scenario3When: "the worker does not respond within the timeout period",
                scenario3Then: "it should emit a timeout error and potentially restart the worker",
                customProperties: "workerPort - EventEmitter: connected worker instance\ntimeoutMs - number: worker timeout in milliseconds\nretryCount - number: maximum retry attempts",
                additionalContext: "Should handle worker lifecycle, implement circuit breaker pattern, support worker health checks"
            },
            http_worker: {
                nodeTitle: "HTTP Worker",
                nodeType: "TRANSDUCER",
                userRole: "developer",
                userWant: "a worker that can fetch data from HTTP endpoints reliably",
                userBenefit: "I can build robust data fetching pipelines with proper error handling",
                scenario1Title: "Successful HTTP request",
                scenario1Given: "the worker receives a packet with a valid URL and request options",
                scenario1When: "the HTTP request is made to the endpoint",
                scenario1Then: "it should emit a packet with the response data and success status",
                scenario2Title: "Handle HTTP error responses",
                scenario2Given: "the worker receives a request packet for an endpoint that returns 404",
                scenario2When: "the HTTP request fails with a client error",
                scenario2Then: "it should emit an error packet with the HTTP status and error details",
                scenario3Title: "Handle network timeouts",
                scenario3Given: "the worker receives a request packet for a slow endpoint",
                scenario3When: "the request exceeds the configured timeout",
                scenario3Then: "it should emit a timeout error and cancel the request",
                customProperties: "timeout - number: request timeout in milliseconds\nretries - number: number of retry attempts\nheaders - object: default HTTP headers",
                additionalContext: "Should support all HTTP methods, handle redirects, implement exponential backoff for retries"
            },
            push_queue: {
                nodeTitle: "Push Queue",
                nodeType: "TRANSDUCER",
                userRole: "system designer",
                userWant: "a queue that actively stores and distributes data to connected consumers",
                userBenefit: "I can build decoupled systems with reliable data distribution",
                scenario1Title: "Store and distribute data",
                scenario1Given: "the queue receives input data packets",
                scenario1When: "consumers are connected to the queue's output",
                scenario1Then: "it should store the data and push it to all connected consumers",
                scenario2Title: "Handle queue overflow",
                scenario2Given: "the queue is at maximum capacity",
                scenario2When: "new data packets arrive",
                scenario2Then: "it should emit a backpressure signal and handle overflow according to policy",
                scenario3Title: "Manage consumer disconnection",
                scenario3Given: "the queue has data and multiple consumers",
                scenario3When: "one consumer disconnects unexpectedly",
                scenario3Then: "it should continue serving other consumers and handle reconnection gracefully",
                customProperties: "maxSize - number: maximum queue capacity\noverflowPolicy - string: 'drop', 'block', or 'error'\nperiodicEmit - boolean: enable periodic data emission",
                additionalContext: "Should implement high watermark notifications, support priority queuing, provide queue statistics"
            },
            pull_queue: {
                nodeTitle: "Pull Queue",
                nodeType: "PRODUCER",
                userRole: "system designer",
                userWant: "a queue that provides data on-demand when requested by consumers",
                userBenefit: "I can build pull-based processing systems with consumer-controlled flow",
                scenario1Title: "Serve data on request",
                scenario1Given: "the queue has stored data packets",
                scenario1When: "a consumer requests data from the queue",
                scenario1Then: "it should emit the next available data packet to the requesting consumer",
                scenario2Title: "Handle empty queue requests",
                scenario2Given: "the queue is empty",
                scenario2When: "a consumer requests data",
                scenario2Then: "it should emit an empty response or wait signal depending on configuration",
                scenario3Title: "Manage concurrent requests",
                scenario3Given: "multiple consumers request data simultaneously",
                scenario3When: "the queue has limited data available",
                scenario3Then: "it should fairly distribute data according to the configured scheduling policy",
                customProperties: "waitPolicy - string: 'immediate', 'block', or 'callback'\nscheduling - string: 'fifo', 'lifo', or 'round-robin'\nmaxWaiters - number: maximum number of waiting consumers",
                additionalContext: "Should support priority consumers, implement fair queuing, provide queue depth monitoring"
            },
            http_fetch: {
                nodeTitle: "HTTP Fetch",
                nodeType: "TRANSDUCER",
                userRole: "developer",
                userWant: "to make HTTP requests and retrieve web content or API data",
                userBenefit: "I can integrate external data sources into my processing pipeline",
                scenario1Title: "Fetch JSON data successfully",
                scenario1Given: "the node receives a packet with a URL to a JSON API endpoint",
                scenario1When: "the HTTP GET request is made",
                scenario1Then: "it should emit a packet with the parsed JSON response data",
                scenario2Title: "Handle non-JSON responses",
                scenario2Given: "the node receives a URL that returns plain text or HTML",
                scenario2When: "the request is successful but content is not JSON",
                scenario2Then: "it should emit the raw response data with appropriate content type",
                scenario3Title: "Handle network failures",
                scenario3Given: "the node receives a URL for an unreachable server",
                scenario3When: "the request fails due to network issues",
                scenario3Then: "it should emit an error packet with network failure details",
                customProperties: "method - string: HTTP method (GET, POST, etc.)\nheaders - object: custom headers to send\nautoParseJson - boolean: automatically parse JSON responses",
                additionalContext: "Should support request body for POST/PUT, handle CORS, implement request caching"
            },
            json_parser: {
                nodeTitle: "JSON Parser",
                nodeType: "TRANSDUCER",
                userRole: "data engineer",
                userWant: "to parse JSON strings into JavaScript objects for further processing",
                userBenefit: "I can transform JSON data into usable objects in my processing pipeline",
                scenario1Title: "Parse valid JSON successfully",
                scenario1Given: "the node receives a packet containing a valid JSON string",
                scenario1When: "the JSON parsing is attempted",
                scenario1Then: "it should emit a packet with the parsed JavaScript object",
                scenario2Title: "Handle malformed JSON gracefully",
                scenario2Given: "the node receives a packet with invalid JSON syntax",
                scenario2When: "JSON.parse() throws a syntax error",
                scenario2Then: "it should emit an error packet with parsing error details",
                scenario3Title: "Handle non-string input",
                scenario3Given: "the node receives a packet with non-string data",
                scenario3When: "the parsing function is called",
                scenario3Then: "it should either convert to string first or emit appropriate error",
                customProperties: "strictMode - boolean: enforce strict JSON parsing\nreviver - function: custom reviver function for parsing\nerrorPolicy - string: 'emit', 'skip', or 'throw'",
                additionalContext: "Should support streaming JSON parsing for large documents, handle circular references"
            }
        };

        // Load profile function
        function loadProfile() {
            const selector = document.getElementById('profileSelector');
            const profileKey = selector.value;

            if (!profileKey) {
                // Reset to empty form
                initFormData();
                updateFormFields();
                return;
            }

            const profile = profiles[profileKey];
            if (profile) {
                // Update form data with profile values
                Object.keys(profile).forEach(key => {
                    if (formData.hasOwnProperty(key)) {
                        formData[key] = profile[key];
                    }
                });
                updateFormFields();
                updateFormDataDisplay();

                // Show success message
                const btn = selector.nextElementSibling;
                if (btn && btn.classList.contains('text-muted')) {
                    btn.textContent = `âœ… Loaded ${profile.nodeTitle} profile`;
                    btn.className = 'text-success';
                    setTimeout(() => {
                        btn.textContent = 'ðŸ’¡ Profiles provide powerful design patterns you can customize';
                        btn.className = 'text-muted';
                    }, 3000);
                }
            }
        }

        // Update form fields with current data
        function updateFormFields() {
            Object.keys(formData).forEach(fieldName => {
                const element = document.getElementById(fieldName);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = formData[fieldName];
                    } else {
                        element.value = formData[fieldName];
                    }
                }
            });
        }

        // Initialize form data
        function initFormData() {
            form.forEach(pane => {
                pane.forEach(field => {
                    if (field.type === 'checkbox') {
                        formData[field.name] = field.value || false;
                    } else {
                        formData[field.name] = field.value || '';
                    }
                });
            });
            updateFormDataDisplay();
        }

        // Update form data display
        function updateFormDataDisplay() {
            document.getElementById('formData').textContent = JSON.stringify(formData, null, 2);
        }

        // Text input
        function createTextInput(config) {
            const wrapper = document.createElement('div');
            wrapper.className = 'mb-3';

            const label = document.createElement('label');
            label.className = 'form-label';
            label.setAttribute('for', config.name);
            label.textContent = config.label;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control';
            input.id = config.name;
            input.name = config.name;
            input.value = config.value || '';
            if (config.placeholder) input.placeholder = config.placeholder;
            if (config.required) input.required = true;

            input.addEventListener('input', (e) => {
                formData[config.name] = e.target.value;
                updateFormDataDisplay();
            });

            wrapper.appendChild(label);
            wrapper.appendChild(input);

            if (config.description) {
                const helpText = document.createElement('div');
                helpText.className = 'form-text';
                helpText.textContent = config.description;
                wrapper.appendChild(helpText);
            }

            return wrapper;
        }

        // Textarea
        function createTextarea(config) {
            const wrapper = document.createElement('div');
            wrapper.className = 'mb-3';

            const label = document.createElement('label');
            label.className = 'form-label';
            label.setAttribute('for', config.name);
            label.textContent = config.label;

            const textarea = document.createElement('textarea');
            textarea.className = 'form-control';
            textarea.id = config.name;
            textarea.name = config.name;
            textarea.value = config.value || '';
            if (config.rows) textarea.rows = config.rows;
            if (config.placeholder) textarea.placeholder = config.placeholder;
            if (config.required) textarea.required = true;

            textarea.addEventListener('input', (e) => {
                formData[config.name] = e.target.value;
                updateFormDataDisplay();
            });

            wrapper.appendChild(label);
            wrapper.appendChild(textarea);

            if (config.description) {
                const helpText = document.createElement('div');
                helpText.className = 'form-text';
                helpText.textContent = config.description;
                wrapper.appendChild(helpText);
            }

            return wrapper;
        }

        // Select
        function createSelect(config) {
            const wrapper = document.createElement('div');
            wrapper.className = 'mb-3';

            const label = document.createElement('label');
            label.className = 'form-label';
            label.setAttribute('for', config.name);
            label.textContent = config.label;

            const select = document.createElement('select');
            select.className = 'form-select';
            select.id = config.name;
            select.name = config.name;
            if (config.required) select.required = true;

            config.options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option.value;
                optionElement.textContent = option.text;
                if (config.value === option.value) optionElement.selected = true;
                select.appendChild(optionElement);
            });

            select.addEventListener('change', (e) => {
                formData[config.name] = e.target.value;
                updateFormDataDisplay();
            });

            wrapper.appendChild(label);
            wrapper.appendChild(select);

            if (config.description) {
                const helpText = document.createElement('div');
                helpText.className = 'form-text';
                helpText.textContent = config.description;
                wrapper.appendChild(helpText);
            }

            return wrapper;
        }

        // Create form field
        function createFormField(config) {
            switch (config.type) {
                case 'text':
                    return createTextInput(config);
                case 'textarea':
                    return createTextarea(config);
                case 'select':
                    return createSelect(config);
                default:
                    return createTextInput(config);
            }
        }

        // Create accordion
        function createAccordion() {
            const accordion = document.createElement('div');
            accordion.className = 'accordion';
            accordion.id = 'wizardAccordion';

            const paneNames = [
                'ðŸ“‹ Basic Information',
                'ðŸ‘¤ User Story (BDD Narrative)',
                'ðŸ§ª Test Scenario 1',
                'ðŸ§ª Test Scenario 2',
                'ðŸ§ª Test Scenario 3',
                'âš™ï¸ Advanced Configuration'
            ];

            form.forEach((pane, paneIndex) => {
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';

                const accordionHeader = document.createElement('h2');
                accordionHeader.className = 'accordion-header';

                const accordionButton = document.createElement('button');
                accordionButton.className = 'accordion-button';
                accordionButton.type = 'button';
                accordionButton.setAttribute('data-bs-toggle', 'collapse');
                accordionButton.setAttribute('data-bs-target', `#collapse${paneIndex}`);
                accordionButton.setAttribute('aria-expanded', paneIndex === 0 ? 'true' : 'false');
                accordionButton.setAttribute('aria-controls', `collapse${paneIndex}`);
                accordionButton.textContent = paneNames[paneIndex] || `Step ${paneIndex + 1}`;

                if (paneIndex !== 0) {
                    accordionButton.classList.add('collapsed');
                }

                accordionHeader.appendChild(accordionButton);

                const accordionCollapse = document.createElement('div');
                accordionCollapse.id = `collapse${paneIndex}`;
                accordionCollapse.className = paneIndex === 0 ? 'accordion-collapse collapse show' : 'accordion-collapse collapse';
                accordionCollapse.setAttribute('data-bs-parent', '#wizardAccordion');

                const accordionBody = document.createElement('div');
                accordionBody.className = 'accordion-body';

                pane.forEach(fieldConfig => {
                    const fieldElement = createFormField(fieldConfig);
                    accordionBody.appendChild(fieldElement);
                });

                accordionCollapse.appendChild(accordionBody);
                accordionItem.appendChild(accordionHeader);
                accordionItem.appendChild(accordionCollapse);
                accordion.appendChild(accordionItem);
            });

            return accordion;
        }

        // Generate AI prompt
        function generatePrompt() {
            // Validate required fields
            const requiredFields = [
                'nodeTitle', 'nodeType', 'userRole', 'userWant', 'userBenefit',
                'scenario1Title', 'scenario1Given', 'scenario1When', 'scenario1Then'
            ];

            const missingFields = requiredFields.filter(field => !formData[field] ) ;

            if (missingFields.length > 0) {
                alert(`Please fill out all required fields. Missing: ${missingFields.join(', ')}`);
                return;
            }

            const prompt = generateAIPrompt();
            document.getElementById('generatedPrompt').textContent = prompt;
            document.getElementById('promptOutput').style.display = 'block';
            document.getElementById('promptOutput').scrollIntoView({ behavior: 'smooth' });
        }

        // Generate the actual AI prompt text
        function generateAIPrompt() {
            let prompt = `# Visual Programming Node Generator

Create a ${formData.nodeType} node for a visual programming environment. Generate both the EventEmitter class and manifest.json file.

## Node Specification

**Title:** ${formData.nodeTitle}
**Type:** ${formData.nodeType}

## User Story (BDD Format)

**Narrative:**
- **As a** ${formData.userRole}
- **I want** ${formData.userWant}
- **So that** ${formData.userBenefit}

## Acceptance Criteria

### Scenario 1: ${formData.scenario1Title}
- **Given** ${formData.scenario1Given}
- **When** ${formData.scenario1When}
- **Then** ${formData.scenario1Then}
`;

            // Add scenario 2 if provided
            if (formData.scenario2Title && formData.scenario2Given && formData.scenario2When && formData.scenario2Then) {
                prompt += `
### Scenario 2: ${formData.scenario2Title}
- **Given** ${formData.scenario2Given}
- **When** ${formData.scenario2When}
- **Then** ${formData.scenario2Then}
`;
            }

            // Add scenario 3 if provided
            if (formData.scenario3Title && formData.scenario3Given && formData.scenario3When && formData.scenario3Then) {
                prompt += `
### Scenario 3: ${formData.scenario3Title}
- **Given** ${formData.scenario3Given}
- **When** ${formData.scenario3When}
- **Then** ${formData.scenario3Then}
`;
            }

            // Add custom properties if provided
            if (formData.customProperties && formData.customProperties.trim()) {
                prompt += `
## Custom Properties
${formData.customProperties}
`;
            }

            // Add additional context if provided
            if (formData.additionalContext && formData.additionalContext.trim()) {
                prompt += `
## Additional Requirements
${formData.additionalContext}
`;
            }

            prompt += `
## Technical Requirements

### Packet Structure
\`\`\`javascript
packet = {
  meta: {
    id: guid,
    ver: [2, guid],
    producer: originalProducerId,
    transducer: previousNodeId
  },
  data: {
    type: mime?,
    content: "actual data",
    // other properties as needed
  }
}
\`\`\`

### EventEmitter Template
\`\`\`javascript
class MyNode extends EventEmitter {
    constructor() {
        super();
        this.on('input', packet => this.process(packet));
    }

    rev = '1-guid-hexadecimal';

    #processor = (packet) => packet;

    upgrade(rev, fn) {
        if (this.rev > rev) return;
        this.#processor = fn;
    }

    process(packet) {
        const result = this.#processor(packet);
        this.emit('output', result);
    }

    start() {
        // mount/initialize
    }

    stop() {
        // destroy/terminate
    }
}
\`\`\`

### Manifest.json Structure
Include:
- node.input ports (for TRANSDUCER/REDUCER)
- node.output ports (for PRODUCER/TRANSDUCER)
- node.properties (for custom configuration)
- Proper datatypes and descriptions

## Deliverables
1. Complete EventEmitter class implementation
2. Complete manifest.json file
3. Simple test implementation based on the BDD scenarios
4. Brief usage documentation

Generate code that follows the packet structure, implements the test scenarios, and provides a clean, simple node that does one thing well.`;

            return prompt;
        }

        // Copy prompt to clipboard
        function copyPrompt() {
            const promptText = document.getElementById('generatedPrompt').textContent;
            navigator.clipboard.writeText(promptText).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ… Copied!';
                btn.className = 'btn btn-success mt-2';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.className = 'btn btn-outline-primary mt-2';
                }, 2000);
            });
        }

        // Initialize form
        function initForm() {
            initFormData();
            const formContainer = document.getElementById('wizardForm');
            const accordion = createAccordion();
            formContainer.appendChild(accordion);
        }

        // Reset form
        function resetForm() {
            initFormData();
            document.getElementById('wizardForm').innerHTML = '';
            document.getElementById('promptOutput').style.display = 'none';
            initForm();
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initForm);
    </script>
</body>
</html>
